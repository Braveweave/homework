// Generated by CoffeeScript 1.7.1
(function() {
  var CompileError, Compiler, EmptyNode, EndOfTokenStreamError, FormulaMinusNode, FormulaNode, Lexer, Node, NumberNode, Parser, Token, input, lexer, parser, root,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  CompileError = (function() {
    CompileError.prototype.name = 'compile error';

    function CompileError(message) {
      this.message = message;
    }

    return CompileError;

  })();

  Token = (function() {
    function Token(type, value, position) {
      this.type = type;
      this.value = value;
      this.position = position;
    }

    Token.prototype.getType = function() {
      return this.type;
    };

    Token.prototype.getValue = function() {
      return this.value;
    };

    Token.prototype.getPosition = function() {
      return this.position;
    };

    Token.prototype.isType = function(type) {
      return this.type === type;
    };

    return Token;

  })();

  Token.NUMBER = 'NUMBER';

  Token.OPERATOR = 'OPERATOR';

  Token.patterns = {
    'NUMBER': /([0-9]+)/i,
    'OPERATOR': /(\+|\-)/i
  };

  Node = (function() {
    function Node() {}

    return Node;

  })();

  FormulaNode = (function(_super) {
    __extends(FormulaNode, _super);

    function FormulaNode(number, formulaMinus) {
      this.number = number;
      this.formulaMinus = formulaMinus;
    }

    return FormulaNode;

  })(Node);

  FormulaMinusNode = (function(_super) {
    __extends(FormulaMinusNode, _super);

    function FormulaMinusNode(op, formula) {
      this.op = op;
      this.formula = formula;
    }

    return FormulaMinusNode;

  })(Node);

  NumberNode = (function(_super) {
    __extends(NumberNode, _super);

    function NumberNode(number) {
      this.number = number;
    }

    return NumberNode;

  })(Node);

  EmptyNode = (function(_super) {
    __extends(EmptyNode, _super);

    function EmptyNode() {
      return EmptyNode.__super__.constructor.apply(this, arguments);
    }

    return EmptyNode;

  })(Node);

  EndOfTokenStreamError = (function() {
    function EndOfTokenStreamError() {}

    return EndOfTokenStreamError;

  })();

  Lexer = (function() {
    Lexer.prototype.patterns = null;

    Lexer.prototype.stream = '';

    Lexer.prototype.position = 0;

    Lexer.prototype.token = null;

    Lexer.prototype.whiteSpacePattern = /[ \t]*/;

    function Lexer(patterns) {
      this.patterns = patterns;
    }

    Lexer.prototype.start = function(stream) {
      this.stream = stream;
      this.position = 0;
      this.token = null;
      return this.advance();
    };

    Lexer.prototype.getToken = function() {
      if (this.isStreamFinish()) {
        throw new EndOfTokenStreamError;
      }
      return this.token;
    };

    Lexer.prototype.advance = function() {
      var match, pattern, type, value, whiteSpaces, _ref;
      if (this.token != null) {
        this.position += this.token.getValue().length;
      }
      if (this.isStreamFinish()) {
        return;
      }
      whiteSpaces = this.whiteSpacePattern.exec(this.getStream());
      if (whiteSpaces != null) {
        this.position += whiteSpaces[0].length;
      }
      _ref = this.patterns;
      for (type in _ref) {
        pattern = _ref[type];
        match = pattern.exec(this.getStream());
        if (!((match != null) && match.index === 0)) {
          continue;
        }
        value = match[0];
        this.token = new Token(type, value, this.position);
        return this.token;
      }
    };

    Lexer.prototype.expect = function(tokenType) {
      if ((this.token == null) || !this.token.isType(tokenType)) {
        throw new CompileError("expect type: " + tokenType + ", got '" + (this.getStream()) + "'");
      }
      return this.token;
    };

    Lexer.prototype.isStreamFinish = function() {
      return this.position >= this.stream.length;
    };

    Lexer.prototype.getStream = function() {
      if (this.isStreamFinish()) {
        return '';
      }
      return this.stream.slice(this.position);
    };

    return Lexer;

  })();

  Parser = (function() {
    function Parser(lexer) {
      this.lexer = lexer;
    }

    Parser.prototype.parseFormula = function() {
      var numberNode, numberToken;
      numberToken = this.lexer.expect(Token.NUMBER);
      numberNode = new NumberNode(numberToken);
      this.lexer.advance();
      return new FormulaNode(numberNode, this.parseFormulaMinus());
    };

    Parser.prototype.parseFormulaMinus = function() {
      var operatorToken;
      if (this.lexer.isStreamFinish()) {
        return new EmptyNode;
      }
      operatorToken = this.lexer.expect(Token.OPERATOR);
      this.lexer.advance();
      return new FormulaMinusNode(operatorToken, this.parseFormula());
    };

    return Parser;

  })();

  Compiler = {
    compile: function(node) {
      if (node instanceof NumberNode) {
        return this.compileNumberNode(node);
      } else if (node instanceof FormulaNode) {
        return this.compileFormulaNode(node);
      } else {
        console.log(node);
        throw new CompileError("compile error: unknown node: " + node);
      }
    },
    compileFormulaNode: function(node) {
      var formulaMinus, formulaMinusFormula, left, op, right;
      left = this.compileNumberNode(node.number);
      while (node.formulaMinus instanceof FormulaMinusNode) {
        formulaMinus = node.formulaMinus;
        op = formulaMinus.op.getValue();
        formulaMinusFormula = formulaMinus.formula;
        right = this.compileNumberNode(formulaMinusFormula.number);
        switch (op) {
          case '-':
            left = left - right;
            break;
          case '+':
            left = left + right;
        }
        node = formulaMinusFormula;
      }
      return left;
    },
    compileNumberNode: function(node) {
      return parseInt(node.number.getValue(), 10);
    }
  };

  lexer = new Lexer(Token.patterns);

  input = process.argv.slice(2).join(' ') || '1 + 41';

  lexer.start(input);

  parser = new Parser(lexer);

  root = parser.parseFormula();

  console.log("" + input + " = " + (Compiler.compile(root)));

}).call(this);
